###  붕어빵 판매하기 ###

문제번호 : 11052 번

문제링크 : [https://www.acmicpc.net/problem/11052](https://www.acmicpc.net/problem/11052)

----------

## 문제 ##

강남역에서 붕어빵 장사를 하고 있는 해빈이는 지금 붕어빵이 N개 남았다.

해빈이는 적절히 붕어빵 세트 메뉴를 구성해서 붕어빵을 팔아서 얻을 수 있는 수익을 최대로 만드려고 한다. 붕어빵 세트 메뉴는 붕어빵을 묶어서 파는 것을 의미하고, 세트 메뉴의 가격은 이미 정해져 있다.

붕어빵 i개로 이루어진 세트 메뉴의 가격은 Pi 원이다.

붕어빵이 4개 남아 있고, 1개 팔 때의 가격이 1, 2개는 5, 3개는 6, 4개는 7인 경우에 해빈이가 얻을 수 있는 최대 수익은 10원이다. 2개, 2개로 붕어빵을 팔면 되기 때문이다.

1개 팔 때의 가격이 5, 2개는 2, 3개는 8, 4개는 10 인 경우에는 20이 된다. 1개, 1개, 1개, 1개로 붕어빵을 팔면 되기 때문이다.

마지막으로, 1개 팔 때의 가격이 3, 2개는 5, 3개는 15, 4개는 16인 경우에는 정답은 18이다. 붕어빵을 3개, 1개로 팔면 되기 때문이다.

세트 메뉴의 가격이 주어졌을 때, 해빈이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.

## 입력 ##

첫째 줄에 해빈이가 가지고 있는 붕어빵의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)

둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)


## 출력 ##

해빈이가 얻을 수 있는 최대 수익을 출력한다.


## 예제 ##
### 입력1 ###

	4
	1 5 6 7

### 출력1 ###

	10

------

### 입력2 ###

	5
	10 9 8 7 6

### 출력2 ###

	50


------

### 입력3 ###

	10
	1 1 2 3 5 8 13 21 34 55

### 출력3 ###

	50


## 풀이 ##
다이나믹프로그래밍을 이용한 풀이  
dp[i] 는  붕어빵이 i개일때 해빈이가 얻을 수 있는 최대 수익  
우선 n을 입력받고 p1~pn까지 입력받아 그 값을 dp[]에 넣어둔다.  

첫번째 반복문은 dp값을 2부터 n까지 차례대로 구하는 반복문이고,(dp[1]은 항상 같기 때문에 2부터 한다.)   
두번째 반복문은 첫번째반복문의 j를 가지고 dp[]에 넣을 값을 구하는 반복문이다.

예를 들어 n이 4이고 p1=1,p2=5,p3=6,p4=7 이면 우선 이 값을 배열 dp에 넣고,  
반복문을 돌린다. 

> j=2,i=2 --> dp[2]와 dp[1]+dp[1]이 큰지 계산 후 dp[2]에 넣음   

> j=3,i=2 --> dp[3]과 dp[1]+dp[2]이 큰지 계산 후 dp[3]에 넣음   
> j=3,i=3 --> dp[3]과 dp[2]+dp[1]이 큰지 계산 후 dp[3]에 넣음   

> j=4,i=2 --> dp[4]와 dp[1]+dp[3]이 큰지 계산 후 dp[4]에 넣음   
> j=4,i=3 --> dp[4]와 dp[2]+dp[2]이 큰지 계산 후 dp[4]에 넣음   
> j=4,i=3 --> dp[4]와 dp[3]+dp[1]이 큰지 계산 후 dp[4]에 넣음   

최종적으로 dp[4]에는 붕어빵이 4개일때 얻을 수 있는 가장 큰 값이 들어간다.

## 코드 ##

	#include<iostream>
	#include<cstring>
	#define IOFAST() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
	#include<algorithm>
	
	using namespace std;
	
	int main(){
	
		int n, i, j;
		scanf("%d", &n);
		int* dp = new int[n + 1];
		memset(dp, 0, sizeof(dp));
		for (i = 1; i <= n; i++){
			scanf("%d", dp + i);
	
		}
	
		for (j = 2; j <= n; j++){
			for (i = 2; i <= j; i++){
				dp[j] = max(dp[j], (dp[i - 1] + dp[j - i + 1]));
			}
		}
	
		printf("%d", dp[n]);
	}