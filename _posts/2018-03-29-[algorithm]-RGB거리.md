
## RGB거리  ##

문제번호 : 1149번

문제링크 :[https://www.acmicpc.net/problem/1149](https://www.acmicpc.net/problem/1149)

----------

## 문제 ##
RGB거리에 사는 사람들은 집을 빨강, 초록, 파랑중에 하나로 칠하려고 한다. 또한, 그들은 모든 이웃은 같은 색으로 칠할 수 없다는 규칙도 정했다. 집 i의 이웃은 집 i-1과 집 i+1이다. 처음 집과 마지막 집은 이웃이 아니다.  
각 집을 빨강으로 칠할 때 드는 비용, 초록으로 칠할 때 드는 비용, 파랑으로 드는 비용이 주어질 때, 모든 집을 칠할 때 드는 비용의 최솟값을 구하는 프로그램을 작성하시오.

## 입력 ##
첫째 줄에 집의 수 N이 주어진다. N은 1,000보다 작거나 같다. 둘째 줄부터 N개의 줄에 각 집을 빨강으로 칠할 때, 초록으로 칠할 때, 파랑으로 칠할 때 드는 비용이 주어진다.
## 출력 ##
첫째 줄에 모든 집을 칠할 때 드는 비용의 최솟값을 출력한다.
## 예제 ##

### 입력 ###
	3
	26 40 83
	49 60 57
	13 89 99

### 출력 ###
	96
 
## 풀이 ##
1.n개의 수만큼 RGB값을 넣을 수 있는 이차원 배열선언 dp  
2.각각의 최소값을 넣을 배열선언 data  
3.n을 입력받고,n개의 수만큼의 RGB를 data[1~n][1~3]에 넣는다. 
 
   		data[1][1] =26 data[1][2] =40 data[1][3] =83   
   		data[2][1] =49 data[2][2] =60 data[2][3] =57  
   		data[3][1] =13 data[3][2] =89 data[3][3] =99

4.data[1][1~3]들은 그대로 dp[1][1~3]에 넣고


    	dp[1][1] =26 dp[1][2] =40 dp[1][3] =83   


5.dp[2~n][1~3]들은 각각 처리 해준다.  
dp[2][1]에는 **dp[1][2]**와 dp[1][3]중 작은 값을 자기자신data[2][1]과 합한 값을 넣는다.(같은 열인 dp[1][1]에는 이웃이 되기 때문에 최솟값 계산에서 제외시켜야 한다!)  
dp[2][2]에는 **dp[1][1]**와 dp[1][3]중 작은 값을 자기자신 data[2][2]과 합한 값을 넣는다.  
dp[2][3]은 **dp[1][1]**와 dp[1][2]중 작은 값을 자기자신 data[2][3]과 합한 값을 넣는다.

    	dp[1][1] =26 dp[1][2] =40 dp[1][3] =83   
    	dp[2][1] =89 dp[2][2] =86 dp[2][3] =83

6.dp[3][1~3]도 같은 방식으로 계산하면

       	dp[1][1] =26 dp[1][2] =40 dp[1][3] =83   
    	dp[2][1] =89 dp[2][2] =86 dp[2][3] =83   
    	dp[2][1] =96 dp[2][2] =172 dp[2][3] =185

가 완성된다. 이제 dp의 마지막 행에서의 최솟값을 출력하면 끝 ! 

## 코드 ##

	#include<iostream>
	#include<cstring>
	#define IOFAST() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
	#define min(a,b) a<b?a:b
	using namespace std;

	int dp[4][1002];
	int data[4][1002];
	
	int main(){
		int i, j, n, min;

		cin >> n;
		for (j = 1; j <= n; j++){
			for (i = 1; i <= 3; i++){
				cin >> data[j][i];
			}
		}
		for (j = 1; j <= n; j++){
			if (j == 1){
				dp[j][1] = data[j][1];
				dp[j][2] = data[j][2];
				dp[j][3] = data[j][3];
				continue;
			}
			dp[j][1] = min(dp[j - 1][2] + data[j][1], dp[j - 1][3] + data[j][1]);
			dp[j][2] = min(dp[j - 1][1] + data[j][2], dp[j - 1][3] + data[j][2]);
			dp[j][3] = min(dp[j - 1][1] + data[j][3], dp[j - 1][2] + data[j][3]);
	
		}

		min = min(min(dp[n][1], dp[n][2]), dp[n][3]);
		cout << min;
	}



### 문제 ###

- 각 라인의 최소값을 구하여 그 합을 최종 최솟값으로 구하는 경우 
- 입력이

	1 20 30  
	50 5 6  
	9 3 7  
와같다면 결과값은 13이 될것이다 (원래 결과값 :10 )  
 dp배열의 2행 {70 6 7}까지만 보고 6을 최소값으로 구하여놓고 계산한다면 이와 같은 오류를 범하게 된다 ! ! 

